<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperspeed AI - Immersive Work Environment</title>

    <!-- 1. Tailwind CSS CDN for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 2. Custom CSS for font, layout, and Hyperspeed component -->
    <style>
        /* Import the Inter font for a modern look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');

        :root {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
        }

        /* Hyperspeed CSS (From the resource file) */
        #lights-container {
            /* Full screen container */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0; /* Ensures it stays behind the content */
        }
        #lights-container canvas {
            width: 100%;
            height: 100%;
            display: block;
            /* Optional: Dim the visual for background use */
            opacity: 0.6;
        }
        /* Custom styles for content overlay */
        .content-overlay {
            position: relative;
            z-index: 10;
        }
    </style>

    <!-- 3. Core React and Babel CDNs -->
    <!-- NOTE: We use react@18, which requires createRoot -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. 3D Graphics Library CDNs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 5. Post-Processing Effects Library CDN -->
    <script src="https://unpkg.com/postprocessing@6.30.5/build/postprocessing.js"></script>
</head>
<body class="bg-gray-900 text-white">

    <!-- React Mount Point -->
    <div id="root" class="min-h-screen flex flex-col"></div>

    <!-- 6. Component Code, Presets, and Usage in Babel Script -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const THREE = window.THREE;

        // Access PostProcessing components directly from the global window object (POSTPROCESSING), 
        // which is how the CDN exposes them.
        const {
            BloomEffect,
            EffectComposer,
            EffectPass,
            RenderPass,
            SMAAEffect,
            SMAAPreset
        } = window.POSTPROCESSING;


        // ===============================================
        // PRESETS / CONFIGURATIONS (From sample.txt)
        // ===============================================

        const hyperspeedPresets = {
          two: {
            onSpeedUp: () => {},
            onSlowDown: () => {},
            distortion: 'mountainDistortion',
            length: 400,
            roadWidth: 9,
            islandWidth: 2,
            lanesPerRoad: 3,
            fov: 90,
            fovSpeedUp: 150,
            speedUp: 2,
            carLightsFade: 0.4,
            totalSideLightSticks: 50,
            lightPairsPerRoadWay: 50,
            shoulderLinesWidthPercentage: 0.05,
            brokenLinesWidthPercentage: 0.1,
            brokenLinesLengthPercentage: 0.5,
            lightStickWidth: [0.12, 0.5],
            lightStickHeight: [1.3, 1.7],
            movingAwaySpeed: [60, 80],
            movingCloserSpeed: [-120, -160],
            carLightsLength: [400 * 0.05, 400 * 0.15],
            carLightsRadius: [0.05, 0.14],
            carWidthPercentage: [0.3, 0.5],
            carShiftX: [-0.2, 0.2],
            carFloorSeparation: [0.05, 1],
            colors: {
              roadColor: 0x080808,
              islandColor: 0x0a0a0a,
              background: 0x000000,
              shoulderLines: 0x131318,
              brokenLines: 0x131318,
              leftCars: [0xff102a, 0xeb383e, 0xff102a],
              rightCars: [0xdadafa, 0xbebae3, 0x8f97e4],
              sticks: 0xdadafa
            }
          }
        };

        // ===============================================
        // THREE.JS / HYPERSPEED HELPERS & SHADERS (From sample.txt)
        // ===============================================

        // Helper functions from the resource file
        const random = base => {
          if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];
          return Math.random() * base;
        };

        const pickRandom = arr => {
          if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];
          return arr;
        };

        function lerp(current, target, speed = 0.1, limit = 0.001) {
          let change = (target - current) * speed;
          if (Math.abs(change) < limit) {
            change = target - current;
          }
          return change;
        }

        const distortion_uniforms = {
          uDistortionX: { value: new THREE.Vector2(80, 3) },
          uDistortionY: { value: new THREE.Vector2(-40, 2.5) }
        };

        const distortion_vertex = `
          #define PI 3.14159265358979
          uniform vec2 uDistortionX;
          uniform vec2 uDistortionY;
          float nsin(float val){
            return sin(val) * 0.5 + 0.5;
          }
          vec3 getDistortion(float progress){
            progress = clamp(progress, 0., 1.);
            float xAmp = uDistortionX.r;
            float xFreq = uDistortionX.g;
            float yAmp = uDistortionY.r;
            float yFreq = uDistortionY.g;
            return vec3( 
              xAmp * nsin(progress * PI * xFreq - PI / 2.),
              yAmp * nsin(progress * PI * yFreq - PI / 2.),
              0.
            );
          }
        `;

        // Shader code from resource file
        const carLightsFragment = `
            #define USE_FOG;
            ${THREE.ShaderChunk['fog_pars_fragment']}
            varying vec3 vColor;
            varying vec2 vUv; 
            uniform vec2 uFade;
            void main() {
              vec3 color = vec3(vColor);
              float alpha = smoothstep(uFade.x, uFade.y, vUv.x);
              gl_FragColor = vec4(color, alpha);
              if (gl_FragColor.a < 0.0001) discard;
              ${THREE.ShaderChunk['fog_fragment']}
            }
          `;

        const carLightsVertex = `
            #define USE_FOG;
            ${THREE.ShaderChunk['fog_pars_vertex']}
            attribute vec3 aOffset;
            attribute vec3 aMetrics;
            attribute vec3 aColor;
            uniform float uTravelLength;
            uniform float uTime;
            varying vec2 vUv; 
            varying vec3 vColor; 
            #include <getDistortion_vertex>
            void main() {
              vec3 transformed = position.xyz;
              float radius = aMetrics.r;
              float myLength = aMetrics.g;
              float speed = aMetrics.b;

              transformed.xy *= radius;
              transformed.z *= myLength;

              transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);
              transformed.xy += aOffset.xy;

              float progress = abs(transformed.z / uTravelLength);
              transformed.xyz += getDistortion(progress);

              vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
              gl_Position = projectionMatrix * mvPosition;
              vUv = uv;
              vColor = aColor;
              ${THREE.ShaderChunk['fog_vertex']}
            }
          `;

        const sideSticksVertex = `
            #define USE_FOG;
            ${THREE.ShaderChunk['fog_pars_vertex']}
            attribute float aOffset;
            attribute vec3 aColor;
            attribute vec2 aMetrics;
            uniform float uTravelLength;
            uniform float uTime;
            varying vec3 vColor;
            mat4 rotationY( in float angle ) {
              return mat4(	cos(angle),		0,		sin(angle),	0,
                           0,		1.0,			 0,	0,
                      -sin(angle),	0,		cos(angle),	0,
                      0, 		0,				0,	1);
            }
            #include <getDistortion_vertex>
            void main(){
              vec3 transformed = position.xyz;
              float width = aMetrics.x;
              float height = aMetrics.y;

              transformed.xy *= vec2(width, height);
              float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);

              transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;

              transformed.z += - uTravelLength + time;

              float progress = abs(transformed.z / uTravelLength);
              transformed.xyz += getDistortion(progress);

              transformed.y += height / 2.;
              transformed.x += -width / 2.;
              vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
              gl_Position = projectionMatrix * mvPosition;
              vColor = aColor;
              ${THREE.ShaderChunk['fog_vertex']}
            }
          `;

        const sideSticksFragment = `
            #define USE_FOG;
            ${THREE.ShaderChunk['fog_pars_fragment']}
            varying vec3 vColor;
            void main(){
              vec3 color = vec3(vColor);
              gl_FragColor = vec4(color,1.);
              ${THREE.ShaderChunk['fog_fragment']}
            }
          `;

        const roadMarkings_vars = `
            uniform float uLanes;
            uniform vec3 uBrokenLinesColor;
            uniform vec3 uShoulderLinesColor;
            uniform float uShoulderLinesWidthPercentage;
            uniform float uBrokenLinesWidthPercentage;
            uniform float uBrokenLinesLengthPercentage;
            highp float random(vec2 co) {
              highp float a = 12.9898;
              highp float b = 78.233;
              highp float c = 43758.5453;
              highp float dt = dot(co.xy, vec2(a, b));
              highp float sn = mod(dt, 3.14);
              return fract(sin(sn) * c);
            }
          `;

        const roadMarkings_fragment = `
            uv.y = mod(uv.y + uTime * 0.05, 1.);
            float laneWidth = 1.0 / uLanes;
            float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;
            float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;

            float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));
            float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);

            brokenLines = mix(brokenLines, sideLines, uv.x);
          `;

        const roadBaseFragment = `
            #define USE_FOG;
            varying vec2 vUv; 
            uniform vec3 uColor;
            uniform float uTime;
            #include <roadMarkings_vars>
            ${THREE.ShaderChunk['fog_pars_fragment']}
            void main() {
              vec2 uv = vUv;
              vec3 color = vec3(uColor);
              #include <roadMarkings_fragment>
              gl_FragColor = vec4(color, 1.);
              ${THREE.ShaderChunk['fog_fragment']}
            }
          `;

        const islandFragment = roadBaseFragment
          .replace('#include <roadMarkings_fragment>', '')
          .replace('#include <roadMarkings_vars>', '');

        const roadFragment = roadBaseFragment
          .replace('#include <roadMarkings_fragment>', roadMarkings_fragment)
          .replace('#include <roadMarkings_vars>', roadMarkings_vars);

        const roadVertex = `
            #define USE_FOG;
            uniform float uTime;
            ${THREE.ShaderChunk['fog_pars_vertex']}
            uniform float uTravelLength;
            varying vec2 vUv; 
            #include <getDistortion_vertex>
            void main() {
              vec3 transformed = position.xyz;
              vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);
              transformed.x += distortion.x;
              transformed.z += distortion.y;
              transformed.y += -1. * distortion.z;  
              
              vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
              gl_Position = projectionMatrix * mvPosition;
              vUv = uv;
              ${THREE.ShaderChunk['fog_vertex']}
            }
          `;

        // Distortions map (from resource file)
        let nsin = val => Math.sin(val) * 0.5 + 0.5;
        const mountainUniforms = {
            uFreq: { value: new THREE.Vector3(3, 6, 10) },
            uAmp: { value: new THREE.Vector3(30, 30, 20) }
        };
        const distortions = {
          mountainDistortion: {
            uniforms: mountainUniforms,
            getDistortion: `
              uniform vec3 uAmp;
              uniform vec3 uFreq;
              #define PI 3.14159265358979
              float nsin(float val){
                return sin(val) * 0.5 + 0.5;
              }
              vec3 getDistortion(float progress){
                float movementProgressFix = 0.02;
                return vec3( 
                  cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,
                  nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,
                  nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z
                );
              }
            `,
            getJS: (progress, time) => {
              let movementProgressFix = 0.02;
              let uFreq = mountainUniforms.uFreq.value;
              let uAmp = mountainUniforms.uAmp.value;
              let distortion = new THREE.Vector3(
                Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -
                  Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,
                nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -
                  nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,
                nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -
                  nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z
              );
              let lookAtAmp = new THREE.Vector3(2, 2, 2);
              let lookAtOffset = new THREE.Vector3(0, 0, -5);
              return distortion.multiply(lookAtAmp).add(lookAtOffset);
            }
          },
          // Placeholder for other distortions
        };


        // ===============================================
        // THREE.JS CLASSES (From sample.txt)
        // ===============================================

        class CarLights {
          constructor(webgl, options, colors, speed, fade) {
            this.webgl = webgl;
            this.options = options;
            this.colors = colors;
            this.speed = speed;
            this.fade = fade;
          }

          init() {
            const options = this.options;
            let curve = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1));
            let geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);

            let instanced = new THREE.InstancedBufferGeometry().copy(geometry);
            instanced.instanceCount = options.lightPairsPerRoadWay * 2;

            let laneWidth = options.roadWidth / options.lanesPerRoad;

            let aOffset = [];
            let aMetrics = [];
            let aColor = [];

            let colors = this.colors;
            if (Array.isArray(colors)) {
              colors = colors.map(c => new THREE.Color(c));
            } else {
              colors = new THREE.Color(colors);
            }

            for (let i = 0; i < options.lightPairsPerRoadWay; i++) {
              let radius = random(options.carLightsRadius);
              let length = random(options.carLightsLength);
              let speed = random(this.speed);

              let carLane = i % options.lanesPerRoad;
              let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;

              let carWidth = random(options.carWidthPercentage) * laneWidth;
              let carShiftX = random(options.carShiftX) * laneWidth;
              laneX += carShiftX;

              let offsetY = random(options.carFloorSeparation) + radius * 1.3;

              let offsetZ = -random(options.length);

              aOffset.push(laneX - carWidth / 2);
              aOffset.push(offsetY);
              aOffset.push(offsetZ);

              aOffset.push(laneX + carWidth / 2);
              aOffset.push(offsetY);
              aOffset.push(offsetZ);

              aMetrics.push(radius);
              aMetrics.push(length);
              aMetrics.push(speed);

              aMetrics.push(radius);
              aMetrics.push(length);
              aMetrics.push(speed);

              let color = pickRandom(colors);
              aColor.push(color.r);
              aColor.push(color.g);
              aColor.push(color.b);

              aColor.push(color.r);
              aColor.push(color.g);
              aColor.push(color.b);
            }

            instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false));
            instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false));
            instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));

            let material = new THREE.ShaderMaterial({
              fragmentShader: carLightsFragment,
              vertexShader: carLightsVertex,
              transparent: true,
              uniforms: Object.assign(
                {
                  uTime: { value: 0 },
                  uTravelLength: { value: options.length },
                  uFade: { value: this.fade }
                },
                this.webgl.fogUniforms,
                options.distortion.uniforms
              )
            });

            material.onBeforeCompile = shader => {
              shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
              );
            };

            let mesh = new THREE.Mesh(instanced, material);
            mesh.frustumCulled = false;
            this.webgl.scene.add(mesh);
            this.mesh = mesh;
          }

          update(time) {
            this.mesh.material.uniforms.uTime.value = time;
          }
        }

        class LightsSticks {
          constructor(webgl, options) {
            this.webgl = webgl;
            this.options = options;
          }

          init() {
            const options = this.options;
            const geometry = new THREE.PlaneGeometry(1, 1);
            let instanced = new THREE.InstancedBufferGeometry().copy(geometry);
            let totalSticks = options.totalSideLightSticks;
            instanced.instanceCount = totalSticks;

            let stickoffset = options.length / (totalSticks - 1);
            const aOffset = [];
            const aColor = [];
            const aMetrics = [];

            let colors = options.colors.sticks;
            if (Array.isArray(colors)) {
              colors = colors.map(c => new THREE.Color(c));
            } else {
              colors = new THREE.Color(colors);
            }

            for (let i = 0; i < totalSticks; i++) {
              let width = random(options.lightStickWidth);
              let height = random(options.lightStickHeight);
              aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());

              let color = pickRandom(colors);
              aColor.push(color.r);
              aColor.push(color.g);
              aColor.push(color.b);

              aMetrics.push(width);
              aMetrics.push(height);
            }

            instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false));
            instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));
            instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false));

            const material = new THREE.ShaderMaterial({
              fragmentShader: sideSticksFragment,
              vertexShader: sideSticksVertex,
              side: THREE.DoubleSide,
              uniforms: Object.assign(
                {
                  uTravelLength: { value: options.length },
                  uTime: { value: 0 }
                },
                this.webgl.fogUniforms,
                options.distortion.uniforms
              )
            });

            material.onBeforeCompile = shader => {
              shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
              );
            };

            const mesh = new THREE.Mesh(instanced, material);
            mesh.frustumCulled = false;
            this.webgl.scene.add(mesh);
            this.mesh = mesh;
          }

          update(time) {
            this.mesh.material.uniforms.uTime.value = time;
          }
        }

        class Road {
          constructor(webgl, options) {
            this.webgl = webgl;
            this.options = options;
            this.uTime = { value: 0 };
          }

          createPlane(side, width, isRoad) {
            const options = this.options;
            let segments = 100;
            const geometry = new THREE.PlaneGeometry(
              isRoad ? options.roadWidth : options.islandWidth,
              options.length,
              20,
              segments
            );
            let uniforms = {
              uTravelLength: { value: options.length },
              uColor: { value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor) },
              uTime: this.uTime
            };

            if (isRoad) {
              uniforms = Object.assign(uniforms, {
                uLanes: { value: options.lanesPerRoad },
                uBrokenLinesColor: { value: new THREE.Color(options.colors.brokenLines) },
                uShoulderLinesColor: { value: new THREE.Color(options.colors.shoulderLines) },
                uShoulderLinesWidthPercentage: { value: options.shoulderLinesWidthPercentage },
                uBrokenLinesLengthPercentage: { value: options.brokenLinesLengthPercentage },
                uBrokenLinesWidthPercentage: { value: options.brokenLinesWidthPercentage }
              });
            }

            const material = new THREE.ShaderMaterial({
              fragmentShader: isRoad ? roadFragment : islandFragment,
              vertexShader: roadVertex,
              side: THREE.DoubleSide,
              uniforms: Object.assign(uniforms, this.webgl.fogUniforms, options.distortion.uniforms)
            });

            material.onBeforeCompile = shader => {
              shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
              );
            };

            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.z = -options.length / 2;
            mesh.position.x += (this.options.islandWidth / 2 + options.roadWidth / 2) * side;
            this.webgl.scene.add(mesh);

            return mesh;
          }

          init() {
            this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);
            this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);
            this.island = this.createPlane(0, this.options.islandWidth, false);
          }

          update(time) {
            this.uTime.value = time;
          }
        }

        class App3D {
          constructor(container, options = {}) {
            this.options = options;
            if (this.options.distortion == null) {
              this.options.distortion = {
                uniforms: distortion_uniforms,
                getDistortion: distortion_vertex
              };
            }
            this.container = container;
            this.renderer = new THREE.WebGLRenderer({
              antialias: false,
              alpha: true
            });
            this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.composer = new EffectComposer(this.renderer); 
            container.append(this.renderer.domElement);

            this.camera = new THREE.PerspectiveCamera(
              options.fov,
              container.offsetWidth / container.offsetHeight,
              0.1,
              10000
            );
            this.camera.position.z = -5;
            this.camera.position.y = 8;
            this.camera.position.x = 0;
            this.scene = new THREE.Scene();
            this.scene.background = null;

            let fog = new THREE.Fog(options.colors.background, options.length * 0.2, options.length * 500);
            this.scene.fog = fog;
            this.fogUniforms = {
              fogColor: { value: fog.color },
              fogNear: { value: fog.near },
              fogFar: { value: fog.far }
            };
            this.clock = new THREE.Clock();
            this.assets = {};
            this.disposed = false;

            this.road = new Road(this, options);
            this.leftCarLights = new CarLights(
              this,
              options,
              options.colors.leftCars,
              options.movingAwaySpeed,
              new THREE.Vector2(0, 1 - options.carLightsFade)
            );
            this.rightCarLights = new CarLights(
              this,
              options,
              options.colors.rightCars,
              options.movingCloserSpeed,
              new THREE.Vector2(1, 0 + options.carLightsFade)
            );
            this.leftSticks = new LightsSticks(this, options);

            this.fovTarget = options.fov;
            this.speedUpTarget = 0;
            this.speedUp = 0;
            this.timeOffset = 0;

            this.tick = this.tick.bind(this);
            this.init = this.init.bind(this);
            this.setSize = this.setSize.bind(this);
            this.onMouseDown = this.onMouseDown.bind(this);
            this.onMouseUp = this.onMouseUp.bind(this);

            this.onTouchStart = this.onTouchStart.bind(this);
            this.onTouchEnd = this.onTouchEnd.bind(this);
            this.onContextMenu = this.onContextMenu.bind(this);

            window.addEventListener('resize', this.onWindowResize.bind(this));
          }

          onWindowResize() {
            const width = this.container.offsetWidth;
            const height = this.container.offsetHeight;

            this.renderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
            this.composer.setSize(width, height);
          }

          initPasses() {
            this.renderPass = new RenderPass(this.scene, this.camera);
            this.bloomPass = new EffectPass(
              this.camera,
              new BloomEffect({
                luminanceThreshold: 0.2,
                luminanceSmoothing: 0,
                resolutionScale: 1
              })
            );

            const smaaPass = new EffectPass(
              this.camera,
              new SMAAEffect({
                preset: SMAAPreset.MEDIUM,
                searchImage: SMAAEffect.searchImageDataURL,
                areaImage: SMAAEffect.areaImageDataURL
              })
            );
            this.renderPass.renderToScreen = false;
            this.bloomPass.renderToScreen = false;
            smaaPass.renderToScreen = true;
            this.composer.addPass(this.renderPass);
            this.composer.addPass(this.bloomPass);
            this.composer.addPass(smaaPass);
          }

          loadAssets() {
            const assets = this.assets;
            return new Promise(resolve => {
              const manager = new THREE.LoadingManager(resolve);

              const searchImage = new Image();
              const areaImage = new Image();
              assets.smaa = {};
              searchImage.addEventListener('load', function () {
                assets.smaa.search = this;
                manager.itemEnd('smaa-search');
              });

              areaImage.addEventListener('load', function () {
                assets.smaa.area = this;
                manager.itemEnd('smaa-area');
              });
              manager.itemStart('smaa-search');
              manager.itemStart('smaa-area');

              searchImage.src = SMAAEffect.searchImageDataURL;
              areaImage.src = SMAAEffect.areaImageDataURL;
            });
          }

          init() {
            this.initPasses();
            const options = this.options;
            this.road.init();
            this.leftCarLights.init();

            this.leftCarLights.mesh.position.setX(-options.roadWidth / 2 - options.islandWidth / 2);
            this.rightCarLights.init();
            this.rightCarLights.mesh.position.setX(options.roadWidth / 2 + options.islandWidth / 2);
            this.leftSticks.init();
            this.leftSticks.mesh.position.setX(-(options.roadWidth + options.islandWidth / 2));

            this.container.addEventListener('mousedown', this.onMouseDown);
            this.container.addEventListener('mouseup', this.onMouseUp);
            this.container.addEventListener('mouseout', this.onMouseUp);

            this.container.addEventListener('touchstart', this.onTouchStart, { passive: true });
            this.container.addEventListener('touchend', this.onTouchEnd, { passive: true });
            this.container.addEventListener('touchcancel', this.onTouchEnd, { passive: true });

            this.container.addEventListener('contextmenu', this.onContextMenu);

            this.tick();
          }

          onMouseDown(ev) {
            if (this.options.onSpeedUp) this.options.onSpeedUp(ev);
            this.fovTarget = this.options.fovSpeedUp;
            this.speedUpTarget = this.options.speedUp;
          }

          onMouseUp(ev) {
            if (this.options.onSlowDown) this.options.onSlowDown(ev);
            this.fovTarget = this.options.fov;
            this.speedUpTarget = 0;
          }

          onTouchStart(ev) {
            if (this.options.onSpeedUp) this.options.onSpeedUp(ev);
            this.fovTarget = this.options.fovSpeedUp;
            this.speedUpTarget = this.options.speedUp;
          }

          onTouchEnd(ev) {
            if (this.options.onSlowDown) this.options.onSlowDown(ev);
            this.fovTarget = this.options.fov;
            this.speedUpTarget = 0;
          }

          onContextMenu(ev) {
            ev.preventDefault();
          }

          update(delta) {
            let lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);
            this.speedUp += lerp(this.speedUp, this.speedUpTarget, lerpPercentage, 0.00001);
            this.timeOffset += this.speedUp * delta;

            let time = this.clock.elapsedTime + this.timeOffset;

            this.rightCarLights.update(time);
            this.leftCarLights.update(time);
            this.leftSticks.update(time);
            this.road.update(time);

            let updateCamera = false;
            let fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);
            if (fovChange !== 0) {
              this.camera.fov += fovChange * delta * 6;
              updateCamera = true;
            }

            if (this.options.distortion.getJS) {
              const distortion = this.options.distortion.getJS(0.025, time);

              this.camera.lookAt(
                new THREE.Vector3(
                  this.camera.position.x + distortion.x,
                  this.camera.position.y + distortion.y,
                  this.camera.position.z + distortion.z
                )
              );
              updateCamera = true;
            }
            if (updateCamera) {
              this.camera.updateProjectionMatrix();
            }
          }

          render(delta) {
            this.composer.render(delta);
          }

          dispose() {
            this.disposed = true;

            if (this.renderer) {
              this.renderer.dispose();
            }
            if (this.composer) {
              this.composer.dispose();
            }
            if (this.scene) {
              this.scene.clear();
            }

            window.removeEventListener('resize', this.onWindowResize.bind(this));
            if (this.container) {
              this.container.removeEventListener('mousedown', this.onMouseDown);
              this.container.removeEventListener('mouseup', this.onMouseUp);
              this.container.removeEventListener('mouseout', this.onMouseUp);

              this.container.removeEventListener('touchstart', this.onTouchStart);
              this.container.removeEventListener('touchend', this.onTouchEnd);
              this.container.removeEventListener('touchcancel', this.onTouchEnd);
              this.container.removeEventListener('contextmenu', this.onContextMenu);
            }
          }

          setSize(width, height, updateStyles) {
            this.composer.setSize(width, height, updateStyles);
          }

          tick() {
            if (this.disposed || !this) return;
            if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {
              const canvas = this.renderer.domElement;
              this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
              this.camera.updateProjectionMatrix();
            }
            const delta = this.clock.getDelta();
            this.render(delta);
            this.update(delta);
            requestAnimationFrame(this.tick);
          }
        }

        function resizeRendererToDisplaySize(renderer, setSize) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
            setSize(width, height, false);
          }
          return needResize;
        }


        // ===============================================
        // HYPERSPEED REACT COMPONENT (The Reusable Component)
        // ===============================================

        const Hyperspeed = ({
          effectOptions = {
            distortion: 'mountainDistortion',
            length: 400,
            roadWidth: 10,
            islandWidth: 2,
            lanesPerRoad: 4,
            fov: 90,
            fovSpeedUp: 150,
            speedUp: 2,
            carLightsFade: 0.4,
            totalSideLightSticks: 20,
            lightPairsPerRoadWay: 40,
            shoulderLinesWidthPercentage: 0.05,
            brokenLinesWidthPercentage: 0.1,
            brokenLinesLengthPercentage: 0.5,
            lightStickWidth: [0.12, 0.5],
            lightStickHeight: [1.3, 1.7],
            movingAwaySpeed: [60, 80],
            movingCloserSpeed: [-120, -160],
            carLightsLength: [400 * 0.03, 400 * 0.2],
            carLightsRadius: [0.05, 0.14],
            carWidthPercentage: [0.3, 0.5],
            carShiftX: [-0.8, 0.8],
            carFloorSeparation: [0, 5],
            colors: {
              roadColor: 0x080808,
              islandColor: 0x0a0a0a,
              background: 0x000000,
              shoulderLines: 0xffffff,
              brokenLines: 0xffffff,
              leftCars: [0xd856bf, 0x6750a2, 0xc247ac],
              rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],
              sticks: 0x03b3c3
            }
          }
        }) => {
          const hyperspeedRef = useRef(null);
          const appRef = useRef(null);
        
          useEffect(() => {
            if (appRef.current) {
              appRef.current.dispose();
              const container = document.getElementById('lights-container');
              if (container) {
                while (container.firstChild) {
                  container.removeChild(container.firstChild);
                }
              }
            }
            
            const container = document.getElementById('lights-container');
            if (!container) return; // Safegaurd for mounting
            
            const options = { ...effectOptions };
            // Map the string name to the actual distortion object
            options.distortion = distortions[options.distortion];

            const myApp = new App3D(container, options);
            appRef.current = myApp;
            myApp.loadAssets().then(myApp.init);
            
            return () => {
              if (appRef.current) {
                appRef.current.dispose();
              }
            };
          }, [effectOptions.distortion]); // Re-run if distortion config changes
        
          // The component's purpose is only to hold the container for Three.js
          return <div id="lights-container" ref={hyperspeedRef}></div>;
        };


        // ===============================================
        // APP COMPONENT (The Landing Page Structure and Usage)
        // ===============================================

        const App = () => {
            // Using preset 'two' for a clean, red/blue look
            const EFFECT_CONFIG = hyperspeedPresets.two;

            return (
                <>
                    {/* Hyperspeed Background Component */}
                    <Hyperspeed effectOptions={EFFECT_CONFIG} />

                    {/* Content Overlay (z-index: 10) */}
                    <div className="content-overlay min-h-screen flex flex-col justify-between">
                        
                        {/* Header Section */}
                        <header className="bg-transparent backdrop-blur-md sticky top-0 z-20 shadow-xl">
                            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
                                <div className="text-3xl font-extrabold text-red-500 tracking-wider">
                                    HYPERSPEED.AI
                                </div>
                                <nav className="hidden md:flex space-x-6 font-medium items-center text-gray-300">
                                    <a href="#" className="hover:text-red-400 transition duration-150">API Docs</a>
                                    <a href="#" className="hover:text-red-400 transition duration-150">Blog</a>
                                    <a href="#" className="hover:text-red-400 transition duration-150">Pricing</a>
                                    <a href="#" className="text-white bg-red-600 px-6 py-2 rounded-full shadow-lg hover:bg-red-700 transition duration-150 transform hover:scale-105">Get Started</a>
                                </nav>
                            </div>
                        </header>

                        {/* Main Content / Hero Section */}
                        <main className="flex-grow flex items-center justify-center py-20 px-4">
                            <div className="text-center max-w-4xl backdrop-blur-sm bg-gray-900/50 p-8 rounded-3xl shadow-2xl border-2 border-red-800/50">
                                <h1 className="text-5xl sm:text-6xl lg:text-8xl font-black text-white leading-none mb-6">
                                    The <span className="text-red-500">Fast Lane</span> to Focus.
                                </h1>
                                <p className="text-xl sm:text-2xl text-gray-300 max-w-2xl mx-auto mb-10">
                                    Minimize friction, maximize output. Enter the flow state with AI-powered velocity.
                                </p>
                                <button className="bg-red-600 text-white text-xl font-bold px-10 py-4 rounded-full shadow-2xl hover:bg-red-500 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50">
                                    Start Your 7-Day Trial
                                </button>
                                <p className="text-sm text-gray-400 mt-4">
                                    No credit card required. Instantly deploy your Deep Work environment.
                                </p>
                            </div>
                        </main>

                        {/* Footer Section */}
                        <footer className="bg-transparent py-4 text-center">
                            <p className="text-xs text-gray-500">
                                &copy; 2024 Hyperspeed AI. Visual built on Three.js & PostProcessing.
                            </p>
                        </footer>
                    </div>
                </>
            );
        };
        
        // FIX: Wrap the React rendering in window.onload. This ensures all external scripts
        // (like Three.js and Postprocessing) are fully loaded before the React app tries to use them.
        window.onload = () => {
            const rootElement = document.getElementById('root');
            const root = ReactDOM.createRoot(rootElement);
            root.render(<App />);
        };

    </script>
</body>
</html>

